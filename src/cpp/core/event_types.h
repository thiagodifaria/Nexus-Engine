// src/cpp/core/event_types.h

#pragma once

#include <chrono>
#include <string>
#include <cstdint>

namespace nexus::core {

// Forward declaration to avoid circular dependency
class HighResolutionClock;

/**
 * @enum EventType
 * @brief Type enumeration for all events in the system.
 */
enum class EventType : uint8_t {
    MARKET_DATA = 0,
    TRADING_SIGNAL = 1,
    TRADE_EXECUTION = 2
};

/**
 * @struct Event
 * @brief Base class for all events in the system.
 *
 * This struct serves as the foundation for the type-safe event system.
 * All events inherit from this base and add their specific data fields.
 * Events are designed to be efficiently passed through the event queue
 * without dynamic allocation overhead.
 */
struct Event {
    std::chrono::system_clock::time_point timestamp;
    
    // NEW: High-resolution timing for Phase 3.2
    uint64_t hardware_timestamp_tsc = 0; // Hardware TSC timestamp
    std::chrono::nanoseconds creation_time_ns{0}; // Nanosecond precision
    
    /**
     * @brief Virtual destructor to make Event polymorphic for dynamic_cast.
     */
    virtual ~Event() = default;
    
    /**
     * @brief Gets the type of this event.
     * @return The EventType for this specific event.
     */
    virtual EventType get_type() const = 0;
    
    /**
     * @brief Sets hardware timestamp using high-resolution clock.
     * 
     * This method captures both the hardware TSC timestamp and nanosecond
     * precision creation time for ultra-low latency measurement.
     */
    void set_hardware_timestamp();
};

/**
 * @struct MarketDataEvent
 * @brief Represents incoming market data (OHLCV) for a specific symbol.
 *
 * This event is triggered when new market data arrives from the data feed.
 * It contains all the information needed for strategies to make trading decisions.
 * The event is designed to be cache-friendly with aligned data layout.
 */
struct MarketDataEvent : public Event {
    std::string symbol;
    double open;
    double high;
    double low;
    double close;
    long volume;
    
    /**
     * @brief Gets the event type.
     * @return EventType::MARKET_DATA
     */
    EventType get_type() const override {
        return EventType::MARKET_DATA;
    }
};

/**
 * @struct TradingSignalEvent
 * @brief Represents a trading signal generated by a strategy.
 *
 * This event is created when a strategy determines that a trading action
 * should be taken. It contains all the information needed for the execution
 * engine to place an order, including risk management parameters.
 */
struct TradingSignalEvent : public Event {
    /**
     * @enum SignalType
     * @brief Type-safe enumeration for trading signals.
     */
    enum class SignalType : uint8_t {
        BUY = 0,
        SELL = 1,
        HOLD = 2,
        EXIT = 3
    };

    std::string strategy_id;
    std::string symbol;
    SignalType signal;
    double confidence;           // Signal confidence (0.0 to 1.0)
    double suggested_quantity;   // Suggested position size
    
    /**
     * @brief Gets the event type.
     * @return EventType::TRADING_SIGNAL
     */
    EventType get_type() const override {
        return EventType::TRADING_SIGNAL;
    }
};

/**
 * @struct TradeExecutionEvent
 * @brief Represents the result of an executed trade.
 *
 * This event is generated by the execution engine after a trade has been
 * completed. It contains the actual execution details including any slippage,
 * commissions, and timing information for performance analysis.
 */
struct TradeExecutionEvent : public Event {
    std::string symbol;
    double quantity;    // Positive for buy, negative for sell in some contexts
    double price;       // Actual execution price
    double commission;  // Commission charged for the trade
    bool is_buy;        // True for buy orders, false for sell orders
    
    /**
     * @brief Gets the event type.
     * @return EventType::TRADE_EXECUTION
     */
    EventType get_type() const override {
        return EventType::TRADE_EXECUTION;
    }
};

} // namespace nexus::core

// Implementation of Event::set_hardware_timestamp() at the end to avoid circular dependency
#include "core/high_resolution_clock.h"

namespace nexus::core {

inline void Event::set_hardware_timestamp() {
    hardware_timestamp_tsc = HighResolutionClock::get_tsc();
    creation_time_ns = HighResolutionClock::get_nanoseconds();
}

} // namespace nexus::core